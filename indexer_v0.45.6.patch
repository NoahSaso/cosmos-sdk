diff --git a/simapp/app.go b/simapp/app.go
index 783774aa0..b7eda83e5 100644
--- a/simapp/app.go
+++ b/simapp/app.go
@@ -242,7 +242,7 @@ func NewSimApp(
 		appCodec, keys[banktypes.StoreKey], app.AccountKeeper, app.GetSubspace(banktypes.ModuleName), app.ModuleAccountAddrs(),
 	)
 	stakingKeeper := stakingkeeper.NewKeeper(
-		appCodec, keys[stakingtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName),
+		appCodec, keys[stakingtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName), homePath,
 	)
 	app.MintKeeper = mintkeeper.NewKeeper(
 		appCodec, keys[minttypes.StoreKey], app.GetSubspace(minttypes.ModuleName), &stakingKeeper,
diff --git a/x/gov/keeper/proposal.go b/x/gov/keeper/proposal.go
index 216596932..66aa870d0 100644
--- a/x/gov/keeper/proposal.go
+++ b/x/gov/keeper/proposal.go
@@ -19,6 +19,12 @@ func (keeper Keeper) SubmitProposal(ctx sdk.Context, content types.Content) (typ
 	// to validate the actual parameter changes before the proposal proceeds
 	// through the governance process. State is not persisted.
 	cacheCtx, _ := ctx.CacheContext()
+
+	// INDEXER: Enable `isCheckTx` so that the indexer knows not to index any
+	// state changes that occur during the simulation below. This indexer checks
+	// `isCheckTx` to detect a simulation and not index any state changes.
+	cacheCtx = cacheCtx.WithIsCheckTx(true)
+
 	handler := keeper.router.GetRoute(content.ProposalRoute())
 	if err := handler(cacheCtx, content); err != nil {
 		return types.Proposal{}, sdkerrors.Wrap(types.ErrInvalidProposalContent, err.Error())
diff --git a/x/staking/keeper/indexer.go b/x/staking/keeper/indexer.go
new file mode 100644
index 000000000..f0454501d
--- /dev/null
+++ b/x/staking/keeper/indexer.go
@@ -0,0 +1,79 @@
+package keeper
+
+import (
+	"encoding/json"
+	"fmt"
+	"os"
+	"path/filepath"
+
+	sdktypes "github.com/cosmos/cosmos-sdk/types"
+)
+
+type IndexerSlashEvent struct {
+	Type                      string       `json:"type"`
+	RegisteredBlockHeight     int64        `json:"registeredBlockHeight"`
+	RegisteredBlockTimeUnixMs int64        `json:"registeredBlockTimeUnixMs"`
+	InfractionBlockHeight     int64        `json:"infractionBlockHeight"`
+	ValidatorOperator         string       `json:"validatorOperator"`
+	SlashFactor               sdktypes.Dec `json:"slashFactor"`
+	AmountSlashed             sdktypes.Int `json:"amountSlashed"`
+	EffectiveFraction         sdktypes.Dec `json:"effectiveFraction"`
+	StakedTokensBurned        sdktypes.Int `json:"stakedTokensBurned"`
+}
+
+type IndexerWriter struct {
+	output string
+	file   *os.File
+}
+
+func NewIndexerWriter(homePath string) *IndexerWriter {
+	// Resolve output path.
+	output := filepath.Join(homePath, "indexer", "staking.out")
+	// Create folder if doesn't exist.
+	dir := filepath.Dir(output)
+	if _, err := os.Stat(dir); os.IsNotExist(err) {
+		os.MkdirAll(dir, os.ModePerm)
+	}
+
+	// Open output file, creating if doesn't exist.
+	file, err := os.OpenFile(output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
+	if err != nil {
+		panic(fmt.Errorf("[INDEXER][staking] Failed to open output file. output=%v, error=%w", output, err))
+	}
+
+	return &IndexerWriter{
+		output: output,
+		file:   file,
+	}
+}
+
+// Write slash event to file.
+func (iw *IndexerWriter) WriteSlash(ctx *sdktypes.Context, infractionBlockHeight int64, validatorOperator string, slashFactor sdktypes.Dec, amountSlashed sdktypes.Int, effectiveFraction sdktypes.Dec, stakedTokensBurned sdktypes.Int) {
+	// If checking TX (simulating, not actually executing), do not index.
+	if ctx.IsCheckTx() {
+		return
+	}
+
+	encoder := json.NewEncoder(iw.file)
+
+	// Export event.
+	event := IndexerSlashEvent{
+		Type:                      "slash",
+		RegisteredBlockHeight:     ctx.BlockHeight(),
+		RegisteredBlockTimeUnixMs: ctx.BlockTime().UnixMilli(),
+		InfractionBlockHeight:     infractionBlockHeight,
+		ValidatorOperator:         validatorOperator,
+		SlashFactor:               slashFactor,
+		AmountSlashed:             amountSlashed,
+		EffectiveFraction:         effectiveFraction,
+		StakedTokensBurned:        stakedTokensBurned,
+	}
+	encoder.Encode(event)
+
+	ctx.Logger().Info("[INDEXER][staking] Exported event", "type", event.Type, "registeredBlockHeight", event.RegisteredBlockHeight, "registeredBlockTimeUnixMs", event.RegisteredBlockTimeUnixMs, "infractionBlockHeight", event.InfractionBlockHeight, "validatorOperator", event.ValidatorOperator, "slashFactor", event.SlashFactor, "amountSlashed", event.AmountSlashed, "effectiveFraction", event.EffectiveFraction, "stakedTokensBurned", event.StakedTokensBurned, "output", iw.output)
+}
+
+// Close file.
+func (iw *IndexerWriter) Close() {
+	iw.file.Close()
+}
diff --git a/x/staking/keeper/keeper.go b/x/staking/keeper/keeper.go
index 6211dcf6a..0596f4902 100644
--- a/x/staking/keeper/keeper.go
+++ b/x/staking/keeper/keeper.go
@@ -25,12 +25,15 @@ type Keeper struct {
 	bankKeeper types.BankKeeper
 	hooks      types.StakingHooks
 	paramstore paramtypes.Subspace
+
+	// INDEXER.
+	indexerWriter *IndexerWriter
 }
 
 // NewKeeper creates a new staking Keeper instance
 func NewKeeper(
 	cdc codec.BinaryCodec, key sdk.StoreKey, ak types.AccountKeeper, bk types.BankKeeper,
-	ps paramtypes.Subspace,
+	ps paramtypes.Subspace, homePath string,
 ) Keeper {
 	// set KeyTable if it has not already been set
 	if !ps.HasKeyTable() {
@@ -47,12 +50,13 @@ func NewKeeper(
 	}
 
 	return Keeper{
-		storeKey:   key,
-		cdc:        cdc,
-		authKeeper: ak,
-		bankKeeper: bk,
-		paramstore: ps,
-		hooks:      nil,
+		storeKey:      key,
+		cdc:           cdc,
+		authKeeper:    ak,
+		bankKeeper:    bk,
+		paramstore:    ps,
+		hooks:         nil,
+		indexerWriter: NewIndexerWriter(homePath),
 	}
 }
 
diff --git a/x/staking/keeper/slash.go b/x/staking/keeper/slash.go
index 79c72d401..a38fbc9e6 100644
--- a/x/staking/keeper/slash.go
+++ b/x/staking/keeper/slash.go
@@ -107,8 +107,9 @@ func (k Keeper) Slash(ctx sdk.Context, consAddr sdk.ConsAddress, infractionHeigh
 	tokensToBurn = sdk.MaxInt(tokensToBurn, sdk.ZeroInt()) // defensive.
 
 	// we need to calculate the *effective* slash fraction for distribution
+	effectiveFraction := sdk.ZeroDec()
 	if validator.Tokens.IsPositive() {
-		effectiveFraction := tokensToBurn.ToDec().QuoRoundUp(validator.Tokens.ToDec())
+		effectiveFraction = tokensToBurn.ToDec().QuoRoundUp(validator.Tokens.ToDec())
 		// possible if power has changed
 		if effectiveFraction.GT(sdk.OneDec()) {
 			effectiveFraction = sdk.OneDec()
@@ -134,12 +135,17 @@ func (k Keeper) Slash(ctx sdk.Context, consAddr sdk.ConsAddress, infractionHeigh
 		panic("invalid validator status")
 	}
 
+	validatorOperator := validator.GetOperator().String()
+
 	logger.Info(
 		"validator slashed by slash factor",
-		"validator", validator.GetOperator().String(),
+		"validator", validatorOperator,
 		"slash_factor", slashFactor.String(),
 		"burned", tokensToBurn,
 	)
+
+	// INDEXER.
+	k.indexerWriter.WriteSlash(&ctx, infractionHeight, validatorOperator, slashFactor, slashAmount, effectiveFraction, tokensToBurn)
 }
 
 // jail a validator
