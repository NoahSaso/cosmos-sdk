diff --git a/simapp/app.go b/simapp/app.go
index 783774aa0..cf946446a 100644
--- a/simapp/app.go
+++ b/simapp/app.go
@@ -239,10 +239,10 @@ func NewSimApp(
 		appCodec, keys[authtypes.StoreKey], app.GetSubspace(authtypes.ModuleName), authtypes.ProtoBaseAccount, maccPerms,
 	)
 	app.BankKeeper = bankkeeper.NewBaseKeeper(
-		appCodec, keys[banktypes.StoreKey], app.AccountKeeper, app.GetSubspace(banktypes.ModuleName), app.ModuleAccountAddrs(),
+		appCodec, keys[banktypes.StoreKey], app.AccountKeeper, app.GetSubspace(banktypes.ModuleName), app.ModuleAccountAddrs(), homePath,
 	)
 	stakingKeeper := stakingkeeper.NewKeeper(
-		appCodec, keys[stakingtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName),
+		appCodec, keys[stakingtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName), homePath,
 	)
 	app.MintKeeper = mintkeeper.NewKeeper(
 		appCodec, keys[minttypes.StoreKey], app.GetSubspace(minttypes.ModuleName), &stakingKeeper,
@@ -250,7 +250,7 @@ func NewSimApp(
 	)
 	app.DistrKeeper = distrkeeper.NewKeeper(
 		appCodec, keys[distrtypes.StoreKey], app.GetSubspace(distrtypes.ModuleName), app.AccountKeeper, app.BankKeeper,
-		&stakingKeeper, authtypes.FeeCollectorName, app.ModuleAccountAddrs(),
+		&stakingKeeper, authtypes.FeeCollectorName, app.ModuleAccountAddrs(), homePath,
 	)
 	app.SlashingKeeper = slashingkeeper.NewKeeper(
 		appCodec, keys[slashingtypes.StoreKey], &stakingKeeper, app.GetSubspace(slashingtypes.ModuleName),
diff --git a/x/bank/keeper/genesis.go b/x/bank/keeper/genesis.go
index f77dd591d..e609e38c5 100644
--- a/x/bank/keeper/genesis.go
+++ b/x/bank/keeper/genesis.go
@@ -29,8 +29,63 @@ func (k BaseKeeper) InitGenesis(ctx sdk.Context, genState *types.GenesisState) {
 		panic(fmt.Errorf("genesis supply is incorrect, expected %v, got %v", genState.Supply, totalSupply))
 	}
 
+	// INDEXER.
+	for _, balance := range genState.Balances {
+		for _, coin := range balance.Coins {
+			k.indexerWriter.Write(
+				&ctx,
+				"genesis_balance",
+				coin,
+				// Empty "from" for initial balance.
+				IndexerBankEntity{
+					ModuleName: "",
+					Address:    "",
+					Balance: sdk.Coin{
+						Denom:  coin.GetDenom(),
+						Amount: sdk.NewInt(-1),
+					},
+				},
+				IndexerBankEntity{
+					ModuleName: "",
+					Address:    balance.Address,
+					Balance:    k.GetBalance(ctx, balance.GetAddress(), coin.GetDenom()),
+				},
+				// Genesis supply indexed below, not here.
+				sdk.Coin{
+					Denom:  coin.GetDenom(),
+					Amount: sdk.NewInt(-1),
+				},
+			)
+		}
+	}
+
 	for _, supply := range totalSupply {
 		k.setSupply(ctx, supply)
+
+		// INDEXER.
+		k.indexerWriter.Write(
+			&ctx,
+			"genesis_supply",
+			supply,
+			// Empty "from" and "to" for initial supply.
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    "",
+				Balance: sdk.Coin{
+					Denom:  supply.GetDenom(),
+					Amount: sdk.NewInt(-1),
+				},
+			},
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    "",
+				Balance: sdk.Coin{
+					Denom:  supply.GetDenom(),
+					Amount: sdk.NewInt(-1),
+				},
+			},
+			supply,
+		)
 	}
 
 	for _, meta := range genState.DenomMetadata {
diff --git a/x/bank/keeper/indexer.go b/x/bank/keeper/indexer.go
new file mode 100644
index 000000000..0dc361790
--- /dev/null
+++ b/x/bank/keeper/indexer.go
@@ -0,0 +1,86 @@
+package keeper
+
+import (
+	"encoding/json"
+	"fmt"
+	"os"
+	"path/filepath"
+
+	sdktypes "github.com/cosmos/cosmos-sdk/types"
+)
+
+type IndexerBankEntity struct {
+	ModuleName string        `json:"moduleName"`
+	Address    string        `json:"address"`
+	Balance    sdktypes.Coin `json:"balance"`
+}
+
+type IndexerBankEvent struct {
+	BlockHeight        int64             `json:"blockHeight"`
+	BlockTimeUnixMicro int64             `json:"blockTimeUnixMicro"`
+	Action             string            `json:"action"`
+	Coin               sdktypes.Coin     `json:"coin"`
+	From               IndexerBankEntity `json:"from"`
+	To                 IndexerBankEntity `json:"to"`
+	NewSupply          sdktypes.Coin     `json:"newSupply"`
+}
+
+type IndexerWriter struct {
+	output string
+	file   *os.File
+
+	// Temporary storage used before calling `SendCoins` in SendCoinsFrom*.
+	NextFromModule string
+	NextToModule   string
+}
+
+func NewIndexerWriter(homePath string) *IndexerWriter {
+	// Resolve output path.
+	output := filepath.Join(homePath, "indexer", "bank.txt")
+	// Create folder if doesn't exist.
+	dir := filepath.Dir(output)
+	if _, err := os.Stat(dir); os.IsNotExist(err) {
+		os.MkdirAll(dir, os.ModePerm)
+	}
+
+	// Open output file, creating if doesn't exist.
+	file, err := os.OpenFile(output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
+	if err != nil {
+		panic(fmt.Errorf("[INDEXER][bank] Failed to open output file. output=%v, error=%w", output, err))
+	}
+
+	return &IndexerWriter{
+		output:         output,
+		file:           file,
+		NextFromModule: "",
+		NextToModule:   "",
+	}
+}
+
+// Write event to file.
+func (iw *IndexerWriter) Write(ctx *sdktypes.Context, action string, coin sdktypes.Coin, from IndexerBankEntity, to IndexerBankEntity, newSupply sdktypes.Coin) {
+	// If checking TX (simulating, not actually executing), do not index.
+	if ctx.IsCheckTx() {
+		return
+	}
+
+	encoder := json.NewEncoder(iw.file)
+
+	// Export event.
+	encoder.Encode(IndexerBankEvent{
+		BlockHeight:        ctx.BlockHeight(),
+		BlockTimeUnixMicro: ctx.BlockTime().UnixMicro(),
+		Action:             action,
+		Coin:               coin,
+		From:               from,
+		To:                 to,
+		NewSupply:          newSupply,
+	})
+
+	ctx.Logger().Info("[INDEXER][bank] Exported events", "blockHeight", ctx.BlockHeight(), "action", action, "coin", coin, "from", from, "to", to, "newSupply", newSupply, "output", iw.output)
+}
+
+// Close file.
+func (iw *IndexerWriter) Close() {
+	iw.file.Close()
+}
diff --git a/x/bank/keeper/keeper.go b/x/bank/keeper/keeper.go
index b44a86b3b..74ba2d950 100644
--- a/x/bank/keeper/keeper.go
+++ b/x/bank/keeper/keeper.go
@@ -97,6 +97,7 @@ func NewBaseKeeper(
 	ak types.AccountKeeper,
 	paramSpace paramtypes.Subspace,
 	blockedAddrs map[string]bool,
+	homePath string,
 ) BaseKeeper {
 
 	// set KeyTable if it has not already been set
@@ -105,7 +106,7 @@ func NewBaseKeeper(
 	}
 
 	return BaseKeeper{
-		BaseSendKeeper:         NewBaseSendKeeper(cdc, storeKey, ak, paramSpace, blockedAddrs),
+		BaseSendKeeper:         NewBaseSendKeeper(cdc, storeKey, ak, paramSpace, blockedAddrs, homePath),
 		ak:                     ak,
 		cdc:                    cdc,
 		storeKey:               storeKey,
@@ -117,7 +118,8 @@ func NewBaseKeeper(
 // WithMintCoinsRestriction restricts the bank Keeper used within a specific module to
 // have restricted permissions on minting via function passed in parameter.
 // Previous restriction functions can be nested as such:
-//  bankKeeper.WithMintCoinsRestriction(restriction1).WithMintCoinsRestriction(restriction2)
+//
+//	bankKeeper.WithMintCoinsRestriction(restriction1).WithMintCoinsRestriction(restriction2)
 func (k BaseKeeper) WithMintCoinsRestriction(check MintingRestrictionFn) BaseKeeper {
 	oldRestrictionFn := k.mintCoinsRestrictionFn
 	k.mintCoinsRestrictionFn = func(ctx sdk.Context, coins sdk.Coins) error {
@@ -179,6 +181,33 @@ func (k BaseKeeper) DelegateCoins(ctx sdk.Context, delegatorAddr, moduleAccAddr
 		return err
 	}
 
+	// INDEXER.
+	for _, coin := range amt {
+		k.indexerWriter.Write(
+			&ctx,
+			"delegate",
+			coin,
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    delegatorAddr.String(),
+				Balance:    k.GetBalance(ctx, delegatorAddr, coin.GetDenom()),
+			},
+			IndexerBankEntity{
+				ModuleName: k.indexerWriter.NextToModule,
+				Address:    moduleAccAddr.String(),
+				Balance:    k.GetBalance(ctx, moduleAccAddr, coin.GetDenom()),
+			},
+			// No supply change, so use -1.
+			sdk.Coin{
+				Denom:  coin.GetDenom(),
+				Amount: sdk.NewInt(-1),
+			},
+		)
+	}
+	// Clear temporary module name storage after use since it's set by this
+	// function's caller when necessary.
+	k.indexerWriter.NextToModule = ""
+
 	return nil
 }
 
@@ -211,6 +240,33 @@ func (k BaseKeeper) UndelegateCoins(ctx sdk.Context, moduleAccAddr, delegatorAdd
 		return err
 	}
 
+	// INDEXER.
+	for _, coin := range amt {
+		k.indexerWriter.Write(
+			&ctx,
+			"undelegate",
+			coin,
+			IndexerBankEntity{
+				ModuleName: k.indexerWriter.NextFromModule,
+				Address:    moduleAccAddr.String(),
+				Balance:    k.GetBalance(ctx, moduleAccAddr, coin.GetDenom()),
+			},
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    delegatorAddr.String(),
+				Balance:    k.GetBalance(ctx, delegatorAddr, coin.GetDenom()),
+			},
+			// No supply change, so use -1.
+			sdk.Coin{
+				Denom:  coin.GetDenom(),
+				Amount: sdk.NewInt(-1),
+			},
+		)
+	}
+	// Clear temporary module name storage after use since it's set by this
+	// function's caller when necessary.
+	k.indexerWriter.NextFromModule = ""
+
 	return nil
 }
 
@@ -319,6 +375,9 @@ func (k BaseKeeper) SendCoinsFromModuleToAccount(
 		return sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, "%s is not allowed to receive funds", recipientAddr)
 	}
 
+	// INDEXER.
+	k.indexerWriter.NextFromModule = senderModule
+
 	return k.SendCoins(ctx, senderAddr, recipientAddr, amt)
 }
 
@@ -338,6 +397,10 @@ func (k BaseKeeper) SendCoinsFromModuleToModule(
 		panic(sdkerrors.Wrapf(sdkerrors.ErrUnknownAddress, "module account %s does not exist", recipientModule))
 	}
 
+	// INDEXER.
+	k.indexerWriter.NextFromModule = senderModule
+	k.indexerWriter.NextToModule = recipientModule
+
 	return k.SendCoins(ctx, senderAddr, recipientAcc.GetAddress(), amt)
 }
 
@@ -352,6 +415,9 @@ func (k BaseKeeper) SendCoinsFromAccountToModule(
 		panic(sdkerrors.Wrapf(sdkerrors.ErrUnknownAddress, "module account %s does not exist", recipientModule))
 	}
 
+	// INDEXER.
+	k.indexerWriter.NextToModule = recipientModule
+
 	return k.SendCoins(ctx, senderAddr, recipientAcc.GetAddress(), amt)
 }
 
@@ -371,6 +437,9 @@ func (k BaseKeeper) DelegateCoinsFromAccountToModule(
 		panic(sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, "module account %s does not have permissions to receive delegated coins", recipientModule))
 	}
 
+	// INDEXER.
+	k.indexerWriter.NextToModule = recipientModule
+
 	return k.DelegateCoins(ctx, senderAddr, recipientAcc.GetAddress(), amt)
 }
 
@@ -390,6 +459,9 @@ func (k BaseKeeper) UndelegateCoinsFromModuleToAccount(
 		panic(sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, "module account %s does not have permissions to undelegate coins", senderModule))
 	}
 
+	// INDEXER.
+	k.indexerWriter.NextFromModule = senderModule
+
 	return k.UndelegateCoins(ctx, acc.GetAddress(), recipientAddr, amt)
 }
 
@@ -429,6 +501,31 @@ func (k BaseKeeper) MintCoins(ctx sdk.Context, moduleName string, amounts sdk.Co
 		types.NewCoinMintEvent(acc.GetAddress(), amounts),
 	)
 
+	// INDEXER.
+	moduleAddress := acc.GetAddress()
+	for _, coin := range amounts {
+		k.indexerWriter.Write(
+			&ctx,
+			"mint",
+			coin,
+			// Empty data for "from" entity since the coins were minted from nothing.
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    "",
+				Balance: sdk.Coin{
+					Denom:  coin.GetDenom(),
+					Amount: sdk.NewInt(-1),
+				},
+			},
+			IndexerBankEntity{
+				ModuleName: moduleName,
+				Address:    moduleAddress.String(),
+				Balance:    k.GetBalance(ctx, moduleAddress, coin.GetDenom()),
+			},
+			k.GetSupply(ctx, coin.GetDenom()),
+		)
+	}
+
 	return nil
 }
 
@@ -463,6 +560,31 @@ func (k BaseKeeper) BurnCoins(ctx sdk.Context, moduleName string, amounts sdk.Co
 		types.NewCoinBurnEvent(acc.GetAddress(), amounts),
 	)
 
+	// INDEXER.
+	moduleAddress := acc.GetAddress()
+	for _, coin := range amounts {
+		k.indexerWriter.Write(
+			&ctx,
+			"burn",
+			coin,
+			IndexerBankEntity{
+				ModuleName: moduleName,
+				Address:    moduleAddress.String(),
+				Balance:    k.GetBalance(ctx, moduleAddress, coin.GetDenom()),
+			},
+			// Empty data for "to" entity since the coins were burned.
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    "",
+				Balance: sdk.Coin{
+					Denom:  coin.GetDenom(),
+					Amount: sdk.NewInt(-1),
+				},
+			},
+			k.GetSupply(ctx, coin.GetDenom()),
+		)
+	}
+
 	return nil
 }
 
diff --git a/x/bank/keeper/send.go b/x/bank/keeper/send.go
index 80fdb555b..cc1a624e0 100644
--- a/x/bank/keeper/send.go
+++ b/x/bank/keeper/send.go
@@ -1,6 +1,9 @@
 package keeper
 
 import (
+	"fmt"
+	"strings"
+
 	"github.com/cosmos/cosmos-sdk/codec"
 	"github.com/cosmos/cosmos-sdk/telemetry"
 	sdk "github.com/cosmos/cosmos-sdk/types"
@@ -40,10 +43,13 @@ type BaseSendKeeper struct {
 
 	// list of addresses that are restricted from receiving transactions
 	blockedAddrs map[string]bool
+
+	// INDEXER.
+	indexerWriter *IndexerWriter
 }
 
 func NewBaseSendKeeper(
-	cdc codec.BinaryCodec, storeKey sdk.StoreKey, ak types.AccountKeeper, paramSpace paramtypes.Subspace, blockedAddrs map[string]bool,
+	cdc codec.BinaryCodec, storeKey sdk.StoreKey, ak types.AccountKeeper, paramSpace paramtypes.Subspace, blockedAddrs map[string]bool, homePath string,
 ) BaseSendKeeper {
 
 	return BaseSendKeeper{
@@ -53,6 +59,9 @@ func NewBaseSendKeeper(
 		storeKey:       storeKey,
 		paramSpace:     paramSpace,
 		blockedAddrs:   blockedAddrs,
+
+		// INDEXER.
+		indexerWriter: NewIndexerWriter(homePath),
 	}
 }
 
@@ -125,6 +134,89 @@ func (k BaseSendKeeper) InputOutputCoins(ctx sdk.Context, inputs []types.Input,
 		}
 	}
 
+	// INDEXER.
+	if !ctx.IsCheckTx() {
+		var inputAddresses []string
+		for _, input := range inputs {
+			inputAddresses = append(inputAddresses, input.Address)
+		}
+		joinedInputAddresses := strings.Join(inputAddresses, ",")
+		var outputAddresses []string
+		for _, output := range outputs {
+			outputAddresses = append(outputAddresses, output.Address)
+		}
+		joinedOutputAddresses := strings.Join(outputAddresses, ",")
+
+		for _, input := range inputs {
+			inputAccAddress, err := sdk.AccAddressFromBech32(input.Address)
+			// Should never happen because it was checked above.
+			if err != nil {
+				panic(fmt.Errorf("[INDEXER][bank] InputOutputCoins input address invalid. address=%v, error=%w", input.Address, err))
+			}
+
+			for _, coin := range input.Coins {
+				k.indexerWriter.Write(
+					&ctx,
+					"multisend_in",
+					coin,
+					IndexerBankEntity{
+						ModuleName: "",
+						Address:    input.Address,
+						Balance:    k.GetBalance(ctx, inputAccAddress, coin.GetDenom()),
+					},
+					IndexerBankEntity{
+						ModuleName: "",
+						Address:    joinedOutputAddresses,
+						// -1 for output balance since there are many addresses.
+						Balance: sdk.Coin{
+							Denom:  coin.GetDenom(),
+							Amount: sdk.NewInt(-1),
+						},
+					},
+					// No supply change, so use -1.
+					sdk.Coin{
+						Denom:  coin.GetDenom(),
+						Amount: sdk.NewInt(-1),
+					},
+				)
+			}
+		}
+		for _, output := range outputs {
+			outputAccAddress, err := sdk.AccAddressFromBech32(output.Address)
+			// Should never happen because it was checked above.
+			if err != nil {
+				panic(fmt.Errorf("[INDEXER][bank] InputOutputCoins output address invalid. address=%v, error=%w", output.Address, err))
+			}
+
+			for _, coin := range output.Coins {
+				k.indexerWriter.Write(
+					&ctx,
+					"multisend_out",
+					coin,
+					IndexerBankEntity{
+						ModuleName: "",
+						Address:    joinedInputAddresses,
+						// -1 for input balance since there are many addresses.
+						Balance: sdk.Coin{
+							Denom:  coin.GetDenom(),
+							Amount: sdk.NewInt(-1),
+						},
+					},
+					IndexerBankEntity{
+						ModuleName: "",
+						Address:    output.Address,
+						Balance:    k.GetBalance(ctx, outputAccAddress, coin.GetDenom()),
+					},
+					// No supply change, so use -1.
+					sdk.Coin{
+						Denom:  coin.GetDenom(),
+						Amount: sdk.NewInt(-1),
+					},
+				)
+			}
+		}
+	}
+
 	return nil
 }
 
@@ -164,6 +256,34 @@ func (k BaseSendKeeper) SendCoins(ctx sdk.Context, fromAddr sdk.AccAddress, toAd
 		),
 	})
 
+	// INDEXER.
+	for _, coin := range amt {
+		k.indexerWriter.Write(
+			&ctx,
+			"send",
+			coin,
+			IndexerBankEntity{
+				ModuleName: k.indexerWriter.NextFromModule,
+				Address:    fromAddr.String(),
+				Balance:    k.GetBalance(ctx, fromAddr, coin.GetDenom()),
+			},
+			IndexerBankEntity{
+				ModuleName: k.indexerWriter.NextToModule,
+				Address:    toAddr.String(),
+				Balance:    k.GetBalance(ctx, toAddr, coin.GetDenom()),
+			},
+			// No supply change, so use -1.
+			sdk.Coin{
+				Denom:  coin.GetDenom(),
+				Amount: sdk.NewInt(-1),
+			},
+		)
+	}
+	// Clear temporary module name storage after use since they are set by this
+	// function's caller when necessary.
+	k.indexerWriter.NextFromModule = ""
+	k.indexerWriter.NextToModule = ""
+
 	return nil
 }
 
diff --git a/x/distribution/keeper/delegation.go b/x/distribution/keeper/delegation.go
index 61631da5d..aa6715148 100644
--- a/x/distribution/keeper/delegation.go
+++ b/x/distribution/keeper/delegation.go
@@ -188,5 +188,20 @@ func (k Keeper) withdrawDelegationRewards(ctx sdk.Context, val stakingtypes.Vali
 	// remove delegator starting info
 	k.DeleteDelegatorStartingInfo(ctx, del.GetValidatorAddr(), del.GetDelegatorAddr())
 
+	// INDEXER.
+	if !coins.IsZero() {
+		withdrawAddr := k.GetDelegatorWithdrawAddr(ctx, del.GetDelegatorAddr())
+		for _, coin := range coins {
+			k.indexerWriter.Write(
+				&ctx,
+				"withdraw_delegation_rewards",
+				coin,
+				del.GetDelegatorAddr().String(),
+				del.GetValidatorAddr().String(),
+				withdrawAddr.String(),
+			)
+		}
+	}
+
 	return coins, nil
 }
diff --git a/x/distribution/keeper/indexer.go b/x/distribution/keeper/indexer.go
new file mode 100644
index 000000000..50e71876c
--- /dev/null
+++ b/x/distribution/keeper/indexer.go
@@ -0,0 +1,74 @@
+package keeper
+
+import (
+	"encoding/json"
+	"fmt"
+	"os"
+	"path/filepath"
+
+	sdktypes "github.com/cosmos/cosmos-sdk/types"
+)
+
+type IndexerDistributionEvent struct {
+	BlockHeight              int64         `json:"blockHeight"`
+	BlockTimeUnixMicro       int64         `json:"blockTimeUnixMicro"`
+	Action                   string        `json:"action"`
+	Amount                   sdktypes.Coin `json:"amount"`
+	DelegatorAddress         string        `json:"delegatorAddress"`
+	ValidatorOperatorAddress string        `json:"validatorOperatorAddress"`
+	WithdrawAddress          string        `json:"withdrawAddress"`
+}
+
+type IndexerWriter struct {
+	output string
+	file   *os.File
+}
+
+func NewIndexerWriter(homePath string) *IndexerWriter {
+	// Resolve output path.
+	output := filepath.Join(homePath, "indexer", "distribution.txt")
+	// Create folder if doesn't exist.
+	dir := filepath.Dir(output)
+	if _, err := os.Stat(dir); os.IsNotExist(err) {
+		os.MkdirAll(dir, os.ModePerm)
+	}
+
+	// Open output file, creating if doesn't exist.
+	file, err := os.OpenFile(output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
+	if err != nil {
+		panic(fmt.Errorf("[INDEXER][distribution] Failed to open output file. output=%v, error=%w", output, err))
+	}
+
+	return &IndexerWriter{
+		output: output,
+		file:   file,
+	}
+}
+
+// Write event to file.
+func (iw *IndexerWriter) Write(ctx *sdktypes.Context, action string, amount sdktypes.Coin, delegatorAddress string, validatorOperatorAddress string, withdrawAddress string) {
+	// If checking TX (simulating, not actually executing), do not index.
+	if ctx.IsCheckTx() {
+		return
+	}
+
+	encoder := json.NewEncoder(iw.file)
+
+	// Export event.
+	encoder.Encode(IndexerDistributionEvent{
+		BlockHeight:              ctx.BlockHeight(),
+		BlockTimeUnixMicro:       ctx.BlockTime().UnixMicro(),
+		Action:                   action,
+		Amount:                   amount,
+		DelegatorAddress:         delegatorAddress,
+		ValidatorOperatorAddress: validatorOperatorAddress,
+		WithdrawAddress:          withdrawAddress,
+	})
+
+	ctx.Logger().Info("[INDEXER][distribution] Exported events", "blockHeight", ctx.BlockHeight(), "action", action, "amount", amount, "delegatorAddress", delegatorAddress, "validatorOperatorAddress", validatorOperatorAddress, "output", "withdrawAddress", withdrawAddress, iw.output)
+}
+
+// Close file.
+func (iw *IndexerWriter) Close() {
+	iw.file.Close()
+}
diff --git a/x/distribution/keeper/keeper.go b/x/distribution/keeper/keeper.go
index b139c35f4..e9cb60562 100644
--- a/x/distribution/keeper/keeper.go
+++ b/x/distribution/keeper/keeper.go
@@ -24,13 +24,16 @@ type Keeper struct {
 	blockedAddrs map[string]bool
 
 	feeCollectorName string // name of the FeeCollector ModuleAccount
+
+	// INDEXER.
+	indexerWriter *IndexerWriter
 }
 
 // NewKeeper creates a new distribution Keeper instance
 func NewKeeper(
 	cdc codec.BinaryCodec, key sdk.StoreKey, paramSpace paramtypes.Subspace,
 	ak types.AccountKeeper, bk types.BankKeeper, sk types.StakingKeeper,
-	feeCollectorName string, blockedAddrs map[string]bool,
+	feeCollectorName string, blockedAddrs map[string]bool, homePath string,
 ) Keeper {
 
 	// ensure distribution module account is set
@@ -52,6 +55,7 @@ func NewKeeper(
 		stakingKeeper:    sk,
 		feeCollectorName: feeCollectorName,
 		blockedAddrs:     blockedAddrs,
+		indexerWriter:    NewIndexerWriter(homePath),
 	}
 }
 
diff --git a/x/staking/keeper/delegation.go b/x/staking/keeper/delegation.go
index cf1fec104..1c2b7e209 100644
--- a/x/staking/keeper/delegation.go
+++ b/x/staking/keeper/delegation.go
@@ -704,6 +704,27 @@ func (k Keeper) Delegate(
 	// Call the after-modification hook
 	k.AfterDelegationModified(ctx, delegatorAddress, delegation.GetValidatorAddr())
 
+	// INDEXER.
+	k.indexerWriter.Write(
+		&ctx,
+		"delegate",
+		sdk.NewCoin(k.BondDenom(ctx), bondAmt),
+		newShares,
+		IndexerDelegator{
+			Address: delegation.DelegatorAddress,
+			Shares:  delegation.Shares,
+			Tokens: sdk.NewCoin(
+				k.BondDenom(ctx),
+				validator.TokensFromSharesTruncated(delegation.Shares).RoundInt(),
+			),
+		},
+		IndexerValidator{
+			OperatorAddress: validator.GetOperator().String(),
+			TotalShares:     validator.DelegatorShares,
+			TotalTokens:     sdk.NewCoin(k.BondDenom(ctx), validator.Tokens),
+		},
+	)
+
 	return newShares, nil
 }
 
@@ -767,6 +788,27 @@ func (k Keeper) Unbond(
 		k.RemoveValidator(ctx, validator.GetOperator())
 	}
 
+	// INDEXER.
+	k.indexerWriter.Write(
+		&ctx,
+		"unbond",
+		sdk.NewCoin(k.BondDenom(ctx), amount),
+		shares,
+		IndexerDelegator{
+			Address: delegation.DelegatorAddress,
+			Shares:  delegation.Shares,
+			Tokens: sdk.NewCoin(
+				k.BondDenom(ctx),
+				validator.TokensFromSharesTruncated(delegation.Shares).RoundInt(),
+			),
+		},
+		IndexerValidator{
+			OperatorAddress: validator.GetOperator().String(),
+			TotalShares:     validator.DelegatorShares,
+			TotalTokens:     sdk.NewCoin(k.BondDenom(ctx), validator.Tokens),
+		},
+	)
+
 	return amount, nil
 }
 
diff --git a/x/staking/keeper/indexer.go b/x/staking/keeper/indexer.go
new file mode 100644
index 000000000..461479d75
--- /dev/null
+++ b/x/staking/keeper/indexer.go
@@ -0,0 +1,86 @@
+package keeper
+
+import (
+	"encoding/json"
+	"fmt"
+	"os"
+	"path/filepath"
+
+	sdktypes "github.com/cosmos/cosmos-sdk/types"
+)
+
+type IndexerDelegator struct {
+	Address string        `json:"address"`
+	Shares  sdktypes.Dec  `json:"shares"`
+	Tokens  sdktypes.Coin `json:"tokens"`
+}
+
+type IndexerValidator struct {
+	OperatorAddress string        `json:"operatorAddress"`
+	TotalShares     sdktypes.Dec  `json:"totalShares"`
+	TotalTokens     sdktypes.Coin `json:"totalTokens"`
+}
+
+type IndexerStakingEvent struct {
+	BlockHeight        int64            `json:"blockHeight"`
+	BlockTimeUnixMicro int64            `json:"blockTimeUnixMicro"`
+	Action             string           `json:"action"`
+	Amount             sdktypes.Coin    `json:"amount"`
+	Shares             sdktypes.Dec     `json:"shares"`
+	Delegator          IndexerDelegator `json:"delegator"`
+	Validator          IndexerValidator `json:"validator"`
+}
+
+type IndexerWriter struct {
+	output string
+	file   *os.File
+}
+
+func NewIndexerWriter(homePath string) *IndexerWriter {
+	// Resolve output path.
+	output := filepath.Join(homePath, "indexer", "staking.txt")
+	// Create folder if doesn't exist.
+	dir := filepath.Dir(output)
+	if _, err := os.Stat(dir); os.IsNotExist(err) {
+		os.MkdirAll(dir, os.ModePerm)
+	}
+
+	// Open output file, creating if doesn't exist.
+	file, err := os.OpenFile(output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
+	if err != nil {
+		panic(fmt.Errorf("[INDEXER][staking] Failed to open output file. output=%v, error=%w", output, err))
+	}
+
+	return &IndexerWriter{
+		output: output,
+		file:   file,
+	}
+}
+
+// Write event to file.
+func (iw *IndexerWriter) Write(ctx *sdktypes.Context, action string, amount sdktypes.Coin, shares sdktypes.Dec, delegator IndexerDelegator, validator IndexerValidator) {
+	// If checking TX (simulating, not actually executing), do not index.
+	if ctx.IsCheckTx() {
+		return
+	}
+
+	encoder := json.NewEncoder(iw.file)
+
+	// Export event.
+	encoder.Encode(IndexerStakingEvent{
+		BlockHeight:        ctx.BlockHeight(),
+		BlockTimeUnixMicro: ctx.BlockTime().UnixMicro(),
+		Action:             action,
+		Amount:             amount,
+		Shares:             shares,
+		Delegator:          delegator,
+		Validator:          validator,
+	})
+
+	ctx.Logger().Info("[INDEXER][staking] Exported events", "blockHeight", ctx.BlockHeight(), "action", action, "amount", amount, "shares", shares, "delegator", delegator, "validator", validator, "output", iw.output)
+}
+
+// Close file.
+func (iw *IndexerWriter) Close() {
+	iw.file.Close()
+}
diff --git a/x/staking/keeper/keeper.go b/x/staking/keeper/keeper.go
index 6211dcf6a..0596f4902 100644
--- a/x/staking/keeper/keeper.go
+++ b/x/staking/keeper/keeper.go
@@ -25,12 +25,15 @@ type Keeper struct {
 	bankKeeper types.BankKeeper
 	hooks      types.StakingHooks
 	paramstore paramtypes.Subspace
+
+	// INDEXER.
+	indexerWriter *IndexerWriter
 }
 
 // NewKeeper creates a new staking Keeper instance
 func NewKeeper(
 	cdc codec.BinaryCodec, key sdk.StoreKey, ak types.AccountKeeper, bk types.BankKeeper,
-	ps paramtypes.Subspace,
+	ps paramtypes.Subspace, homePath string,
 ) Keeper {
 	// set KeyTable if it has not already been set
 	if !ps.HasKeyTable() {
@@ -47,12 +50,13 @@ func NewKeeper(
 	}
 
 	return Keeper{
-		storeKey:   key,
-		cdc:        cdc,
-		authKeeper: ak,
-		bankKeeper: bk,
-		paramstore: ps,
-		hooks:      nil,
+		storeKey:      key,
+		cdc:           cdc,
+		authKeeper:    ak,
+		bankKeeper:    bk,
+		paramstore:    ps,
+		hooks:         nil,
+		indexerWriter: NewIndexerWriter(homePath),
 	}
 }
 
