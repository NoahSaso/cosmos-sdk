diff --git a/simapp/app.go b/simapp/app.go
index 783774aa0..a522ee321 100644
--- a/simapp/app.go
+++ b/simapp/app.go
@@ -239,7 +239,7 @@ func NewSimApp(
 		appCodec, keys[authtypes.StoreKey], app.GetSubspace(authtypes.ModuleName), authtypes.ProtoBaseAccount, maccPerms,
 	)
 	app.BankKeeper = bankkeeper.NewBaseKeeper(
-		appCodec, keys[banktypes.StoreKey], app.AccountKeeper, app.GetSubspace(banktypes.ModuleName), app.ModuleAccountAddrs(),
+		appCodec, keys[banktypes.StoreKey], app.AccountKeeper, app.GetSubspace(banktypes.ModuleName), app.ModuleAccountAddrs(), homePath,
 	)
 	stakingKeeper := stakingkeeper.NewKeeper(
 		appCodec, keys[stakingtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName),
diff --git a/x/bank/keeper/genesis.go b/x/bank/keeper/genesis.go
index f77dd591d..e609e38c5 100644
--- a/x/bank/keeper/genesis.go
+++ b/x/bank/keeper/genesis.go
@@ -29,8 +29,63 @@ func (k BaseKeeper) InitGenesis(ctx sdk.Context, genState *types.GenesisState) {
 		panic(fmt.Errorf("genesis supply is incorrect, expected %v, got %v", genState.Supply, totalSupply))
 	}
 
+	// INDEXER.
+	for _, balance := range genState.Balances {
+		for _, coin := range balance.Coins {
+			k.indexerWriter.Write(
+				&ctx,
+				"genesis_balance",
+				coin,
+				// Empty "from" for initial balance.
+				IndexerBankEntity{
+					ModuleName: "",
+					Address:    "",
+					Balance: sdk.Coin{
+						Denom:  coin.GetDenom(),
+						Amount: sdk.NewInt(-1),
+					},
+				},
+				IndexerBankEntity{
+					ModuleName: "",
+					Address:    balance.Address,
+					Balance:    k.GetBalance(ctx, balance.GetAddress(), coin.GetDenom()),
+				},
+				// Genesis supply indexed below, not here.
+				sdk.Coin{
+					Denom:  coin.GetDenom(),
+					Amount: sdk.NewInt(-1),
+				},
+			)
+		}
+	}
+
 	for _, supply := range totalSupply {
 		k.setSupply(ctx, supply)
+
+		// INDEXER.
+		k.indexerWriter.Write(
+			&ctx,
+			"genesis_supply",
+			supply,
+			// Empty "from" and "to" for initial supply.
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    "",
+				Balance: sdk.Coin{
+					Denom:  supply.GetDenom(),
+					Amount: sdk.NewInt(-1),
+				},
+			},
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    "",
+				Balance: sdk.Coin{
+					Denom:  supply.GetDenom(),
+					Amount: sdk.NewInt(-1),
+				},
+			},
+			supply,
+		)
 	}
 
 	for _, meta := range genState.DenomMetadata {
diff --git a/x/bank/keeper/indexer.go b/x/bank/keeper/indexer.go
new file mode 100644
index 000000000..05cbb73a8
--- /dev/null
+++ b/x/bank/keeper/indexer.go
@@ -0,0 +1,80 @@
+package keeper
+
+import (
+	"encoding/json"
+	"fmt"
+	"os"
+	"path/filepath"
+
+	sdktypes "github.com/cosmos/cosmos-sdk/types"
+)
+
+type IndexerBankEntity struct {
+	ModuleName string        `json:"moduleName"`
+	Address    string        `json:"address"`
+	Balance    sdktypes.Coin `json:"balance"`
+}
+
+type IndexerBankEvent struct {
+	BlockHeight        int64             `json:"blockHeight"`
+	BlockTimeUnixMicro int64             `json:"blockTimeUnixMicro"`
+	Action             string            `json:"action"`
+	Coin               sdktypes.Coin     `json:"coin"`
+	From               IndexerBankEntity `json:"from"`
+	To                 IndexerBankEntity `json:"to"`
+	NewSupply          sdktypes.Coin     `json:"newSupply"`
+}
+
+type IndexerWriter struct {
+	output string
+	file   *os.File
+}
+
+func NewIndexerWriter(homePath string) *IndexerWriter {
+	// Resolve output path.
+	output := filepath.Join(homePath, "indexer", "bank.txt")
+	// Create folder if doesn't exist.
+	dir := filepath.Dir(output)
+	if _, err := os.Stat(dir); os.IsNotExist(err) {
+		os.MkdirAll(dir, os.ModePerm)
+	}
+
+	// Open output file, creating if doesn't exist.
+	file, err := os.OpenFile(output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
+	if err != nil {
+		panic(fmt.Errorf("[INDEXER][bank] Failed to open output file. output=%v, error=%w", output, err))
+	}
+
+	return &IndexerWriter{
+		output: output,
+		file:   file,
+	}
+}
+
+// Write event to file.
+func (iw *IndexerWriter) Write(ctx *sdktypes.Context, action string, coin sdktypes.Coin, from IndexerBankEntity, to IndexerBankEntity, newSupply sdktypes.Coin) {
+	// If checking TX (simulating, not actually executing), do not index.
+	if ctx.IsCheckTx() {
+		return
+	}
+
+	encoder := json.NewEncoder(iw.file)
+
+	// Export event.
+	encoder.Encode(IndexerBankEvent{
+		BlockHeight:        ctx.BlockHeight(),
+		BlockTimeUnixMicro: ctx.BlockTime().UnixMicro(),
+		Action:             action,
+		Coin:               coin,
+		From:               from,
+		To:                 to,
+		NewSupply:          newSupply,
+	})
+
+	ctx.Logger().Info("[INDEXER][bank] Exported events", "blockHeight", ctx.BlockHeight(), "action", action, "coin", coin, "from", from, "to", to, "newSupply", newSupply, "output", iw.output)
+}
+
+// Close file.
+func (iw *IndexerWriter) Close() {
+	iw.file.Close()
+}
diff --git a/x/bank/keeper/keeper.go b/x/bank/keeper/keeper.go
index b44a86b3b..9079c3565 100644
--- a/x/bank/keeper/keeper.go
+++ b/x/bank/keeper/keeper.go
@@ -97,6 +97,7 @@ func NewBaseKeeper(
 	ak types.AccountKeeper,
 	paramSpace paramtypes.Subspace,
 	blockedAddrs map[string]bool,
+	homePath string,
 ) BaseKeeper {
 
 	// set KeyTable if it has not already been set
@@ -105,7 +106,7 @@ func NewBaseKeeper(
 	}
 
 	return BaseKeeper{
-		BaseSendKeeper:         NewBaseSendKeeper(cdc, storeKey, ak, paramSpace, blockedAddrs),
+		BaseSendKeeper:         NewBaseSendKeeper(cdc, storeKey, ak, paramSpace, blockedAddrs, homePath),
 		ak:                     ak,
 		cdc:                    cdc,
 		storeKey:               storeKey,
@@ -117,7 +118,8 @@ func NewBaseKeeper(
 // WithMintCoinsRestriction restricts the bank Keeper used within a specific module to
 // have restricted permissions on minting via function passed in parameter.
 // Previous restriction functions can be nested as such:
-//  bankKeeper.WithMintCoinsRestriction(restriction1).WithMintCoinsRestriction(restriction2)
+//
+//	bankKeeper.WithMintCoinsRestriction(restriction1).WithMintCoinsRestriction(restriction2)
 func (k BaseKeeper) WithMintCoinsRestriction(check MintingRestrictionFn) BaseKeeper {
 	oldRestrictionFn := k.mintCoinsRestrictionFn
 	k.mintCoinsRestrictionFn = func(ctx sdk.Context, coins sdk.Coins) error {
@@ -179,6 +181,30 @@ func (k BaseKeeper) DelegateCoins(ctx sdk.Context, delegatorAddr, moduleAccAddr
 		return err
 	}
 
+	// INDEXER.
+	for _, coin := range amt {
+		k.indexerWriter.Write(
+			&ctx,
+			"delegate",
+			coin,
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    delegatorAddr.String(),
+				Balance:    k.GetBalance(ctx, delegatorAddr, coin.GetDenom()),
+			},
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    moduleAccAddr.String(),
+				Balance:    k.GetBalance(ctx, moduleAccAddr, coin.GetDenom()),
+			},
+			// No supply change, so use -1.
+			sdk.Coin{
+				Denom:  coin.GetDenom(),
+				Amount: sdk.NewInt(-1),
+			},
+		)
+	}
+
 	return nil
 }
 
@@ -211,6 +237,30 @@ func (k BaseKeeper) UndelegateCoins(ctx sdk.Context, moduleAccAddr, delegatorAdd
 		return err
 	}
 
+	// INDEXER.
+	for _, coin := range amt {
+		k.indexerWriter.Write(
+			&ctx,
+			"undelegate",
+			coin,
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    moduleAccAddr.String(),
+				Balance:    k.GetBalance(ctx, moduleAccAddr, coin.GetDenom()),
+			},
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    delegatorAddr.String(),
+				Balance:    k.GetBalance(ctx, delegatorAddr, coin.GetDenom()),
+			},
+			// No supply change, so use -1.
+			sdk.Coin{
+				Denom:  coin.GetDenom(),
+				Amount: sdk.NewInt(-1),
+			},
+		)
+	}
+
 	return nil
 }
 
@@ -429,6 +479,31 @@ func (k BaseKeeper) MintCoins(ctx sdk.Context, moduleName string, amounts sdk.Co
 		types.NewCoinMintEvent(acc.GetAddress(), amounts),
 	)
 
+	// INDEXER.
+	moduleAddress := acc.GetAddress()
+	for _, coin := range amounts {
+		k.indexerWriter.Write(
+			&ctx,
+			"mint",
+			coin,
+			// Empty data for "from" entity since the coins were minted from nothing.
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    "",
+				Balance: sdk.Coin{
+					Denom:  coin.GetDenom(),
+					Amount: sdk.NewInt(-1),
+				},
+			},
+			IndexerBankEntity{
+				ModuleName: moduleName,
+				Address:    moduleAddress.String(),
+				Balance:    k.GetBalance(ctx, moduleAddress, coin.GetDenom()),
+			},
+			k.GetSupply(ctx, coin.GetDenom()),
+		)
+	}
+
 	return nil
 }
 
@@ -463,6 +538,31 @@ func (k BaseKeeper) BurnCoins(ctx sdk.Context, moduleName string, amounts sdk.Co
 		types.NewCoinBurnEvent(acc.GetAddress(), amounts),
 	)
 
+	// INDEXER.
+	moduleAddress := acc.GetAddress()
+	for _, coin := range amounts {
+		k.indexerWriter.Write(
+			&ctx,
+			"burn",
+			coin,
+			IndexerBankEntity{
+				ModuleName: moduleName,
+				Address:    moduleAddress.String(),
+				Balance:    k.GetBalance(ctx, moduleAddress, coin.GetDenom()),
+			},
+			// Empty data for "to" entity since the coins were burned.
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    "",
+				Balance: sdk.Coin{
+					Denom:  coin.GetDenom(),
+					Amount: sdk.NewInt(-1),
+				},
+			},
+			k.GetSupply(ctx, coin.GetDenom()),
+		)
+	}
+
 	return nil
 }
 
diff --git a/x/bank/keeper/send.go b/x/bank/keeper/send.go
index 80fdb555b..cd9f7f4e2 100644
--- a/x/bank/keeper/send.go
+++ b/x/bank/keeper/send.go
@@ -1,6 +1,9 @@
 package keeper
 
 import (
+	"fmt"
+	"strings"
+
 	"github.com/cosmos/cosmos-sdk/codec"
 	"github.com/cosmos/cosmos-sdk/telemetry"
 	sdk "github.com/cosmos/cosmos-sdk/types"
@@ -40,10 +43,13 @@ type BaseSendKeeper struct {
 
 	// list of addresses that are restricted from receiving transactions
 	blockedAddrs map[string]bool
+
+	// INDEXER.
+	indexerWriter *IndexerWriter
 }
 
 func NewBaseSendKeeper(
-	cdc codec.BinaryCodec, storeKey sdk.StoreKey, ak types.AccountKeeper, paramSpace paramtypes.Subspace, blockedAddrs map[string]bool,
+	cdc codec.BinaryCodec, storeKey sdk.StoreKey, ak types.AccountKeeper, paramSpace paramtypes.Subspace, blockedAddrs map[string]bool, homePath string,
 ) BaseSendKeeper {
 
 	return BaseSendKeeper{
@@ -53,6 +59,9 @@ func NewBaseSendKeeper(
 		storeKey:       storeKey,
 		paramSpace:     paramSpace,
 		blockedAddrs:   blockedAddrs,
+
+		// INDEXER.
+		indexerWriter: NewIndexerWriter(homePath),
 	}
 }
 
@@ -125,6 +134,89 @@ func (k BaseSendKeeper) InputOutputCoins(ctx sdk.Context, inputs []types.Input,
 		}
 	}
 
+	// INDEXER.
+	if !ctx.IsCheckTx() {
+		var inputAddresses []string
+		for _, input := range inputs {
+			inputAddresses = append(inputAddresses, input.Address)
+		}
+		joinedInputAddresses := strings.Join(inputAddresses, ",")
+		var outputAddresses []string
+		for _, output := range outputs {
+			outputAddresses = append(outputAddresses, output.Address)
+		}
+		joinedOutputAddresses := strings.Join(outputAddresses, ",")
+
+		for _, input := range inputs {
+			inputAccAddress, err := sdk.AccAddressFromBech32(input.Address)
+			// Should never happen because it was checked above.
+			if err != nil {
+				panic(fmt.Errorf("[INDEXER][bank] InputOutputCoins input address invalid. address=%v, error=%w", input.Address, err))
+			}
+
+			for _, coin := range input.Coins {
+				k.indexerWriter.Write(
+					&ctx,
+					"multisend_in",
+					coin,
+					IndexerBankEntity{
+						ModuleName: "",
+						Address:    input.Address,
+						Balance:    k.GetBalance(ctx, inputAccAddress, coin.GetDenom()),
+					},
+					IndexerBankEntity{
+						ModuleName: "",
+						Address:    joinedOutputAddresses,
+						// -1 for output balance since there are many addresses.
+						Balance: sdk.Coin{
+							Denom:  coin.GetDenom(),
+							Amount: sdk.NewInt(-1),
+						},
+					},
+					// No supply change, so use -1.
+					sdk.Coin{
+						Denom:  coin.GetDenom(),
+						Amount: sdk.NewInt(-1),
+					},
+				)
+			}
+		}
+		for _, output := range outputs {
+			outputAccAddress, err := sdk.AccAddressFromBech32(output.Address)
+			// Should never happen because it was checked above.
+			if err != nil {
+				panic(fmt.Errorf("[INDEXER][bank] InputOutputCoins output address invalid. address=%v, error=%w", output.Address, err))
+			}
+
+			for _, coin := range output.Coins {
+				k.indexerWriter.Write(
+					&ctx,
+					"multisend_out",
+					coin,
+					IndexerBankEntity{
+						ModuleName: "",
+						Address:    joinedInputAddresses,
+						// -1 for input balance since there are many addresses.
+						Balance: sdk.Coin{
+							Denom:  coin.GetDenom(),
+							Amount: sdk.NewInt(-1),
+						},
+					},
+					IndexerBankEntity{
+						ModuleName: "",
+						Address:    output.Address,
+						Balance:    k.GetBalance(ctx, outputAccAddress, coin.GetDenom()),
+					},
+					// No supply change, so use -1.
+					sdk.Coin{
+						Denom:  coin.GetDenom(),
+						Amount: sdk.NewInt(-1),
+					},
+				)
+			}
+		}
+	}
+
 	return nil
 }
 
@@ -164,6 +256,30 @@ func (k BaseSendKeeper) SendCoins(ctx sdk.Context, fromAddr sdk.AccAddress, toAd
 		),
 	})
 
+	// INDEXER.
+	for _, coin := range amt {
+		k.indexerWriter.Write(
+			&ctx,
+			"send",
+			coin,
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    fromAddr.String(),
+				Balance:    k.GetBalance(ctx, fromAddr, coin.GetDenom()),
+			},
+			IndexerBankEntity{
+				ModuleName: "",
+				Address:    toAddr.String(),
+				Balance:    k.GetBalance(ctx, toAddr, coin.GetDenom()),
+			},
+			// No supply change, so use -1.
+			sdk.Coin{
+				Denom:  coin.GetDenom(),
+				Amount: sdk.NewInt(-1),
+			},
+		)
+	}
+
 	return nil
 }
 
